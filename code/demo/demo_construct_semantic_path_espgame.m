clear 
clear all
base_path = 'code';
chdir(base_path)
addpath(genpath(pwd))

data_name = 'espgame';

%------------------------------------- load the semantic_hierarchy_structure
load([data_name, '_semantic_hierarchy_structure.mat']); % semantic_hierarchy_structure
num_class = numel(semantic_hierarchy_structure.class_name);

% the following three should be constructed for new data, such as IAPRTC-12
same_meaning_pair = semantic_hierarchy_structure.same_meaning_pair; 
ancestor_cell = semantic_hierarchy_structure.ancestor_cell;
descendant_cell = semantic_hierarchy_structure.descendant_cell;

%-------------------------------------------------------------------------- 
% construct the semantic path based on the semantic hierarchy graph, and same_meaning_pair
semantic_path_cell = {
        [2 44], ...
        [3 60], ...
        [251 60], ...
        [18 4], ...
        [262 23 4], ...
        [43 4], ...
        [72 4], ...
        [92 4], ...
        [127 4], ...
        [132 4], ...
        [158 4], ...
        [5 41 89 160 211], ...
        [5 218], ...
        [90 118 6], ...
        [7 113], ...
        [61 84 113], ...
        [174 113], ...
        [64 113], ...
        [64 175 176], ... % 175--176
        [138 263 175 176], ...
        [224 175 176], ...
        [135 10 175 176], ...
        [48 10 175 176], ...
        [116 150 175 176], ...
        [11 175 176], ...
        [33 175 176], ...
        [47 137 175 176], ... % 47--137
        [104 175 176], ...
        [215 175 176], ...
        [215 161], ...
        [214 161], ...
        [66 9], ...
        [172 9], ...
        [229 9], ...
        [99 14], ...
        [99 103], ...
        [99 226], ...
        [93 226], ...
        [236 226], ...
        [19 83], ...
        [79 83], ...
        [82 83], ...
        [17 159 83], ...
        [145 159 83], ...
        [240 159 83], ...
        [164 83], ...
        [221 83], ...
        [180 56], ...
        [190 56], ...
        [192 56], ...
        [260 56], ...
        [268 56], ...
        [26 56], ...
        [35 56], ...
        [111 56], ...
        [112 56], ...
        [169 56], ...
        [24 56], ...
        [108 56], ...
        [24 67], ...
        [205 67], ...
        [108 152], ...
        [213 152], ...
        [55 152], ...
        [55 155], ...
        [25 117], ...
        [102 117], ...
        [148 29 30], ... % 29--30
        [49 37], ...
        [197 37], ...
        [42 37], ...
        [74 252 37], ...
        [261 252 37], ...
        [95 198 129 37], ...
        [95 198 129 125], ...
        [50 170], ...
        [227 51], ...
        [53 219], ...
        [134 54], ...
        [59 147], ...
        [68 201], ...
        [70 76], ...
        [73 245], ...
        [234 77], ...
        [81 98], ...
        [96 183], ...
        [110 183], ...
        [140 183], ...
        [100 247 183], ...
        [130 255], ...
        [139 255], ...
        [166 255], ...
        [194 255], ...
        [204 255], ...
        [223 255], ...
        [142 265 267], ...
        [171 173], ...
        [232 195], ...
        [250 203], ...
        [235 228], ... % the followings are same meaning pairs that are not in any paths
        [1 181], ...
        [3 251], ...
        [80 107], ...
        [89 160], ...
        [196 230], ...
        [210 231] ...
        }';
num_semantic_path = numel(semantic_path_cell);
index_of_same_meaning_pair_in_path = 101:106; 

% construct the layer of each node in each path
% the bottom node is layer 0, and its parent is layer 1
node_layer_of_each_path = { ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1 2], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1 2 2 3], ...
    [0 1], ...
    [0 1 2], ...
    [0 1], ...
    [0 1 2], ...
    [0 1], ...
    [0 1], ...
    [0 1 1], ...
    [0 1 2 2], ...
    [0 1 1], ...
    [0 1 2 2], ...
    [0 1 2 2], ...
    [0 1 2 2], ...
    [0 1 1], ...
    [0 1 1], ...
    [0 0 1 1], ...
    [0 1 1], ...
    [0 1 1], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1 2], ...
    [0 1 2], ...
    [0 1 2], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1 1], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1 2], ...
    [0 1 2], ...
    [0 1 2 3], ...
    [0 1 2 3], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1 2], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1 2], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 1], ...
    [0 0], ...
    [0 0], ...
    [0 0], ...
    [0 0], ...
    [0 0], ...
    [0 0] ...
};
 
%% weight of each path
num_child_of_each_class = arrayfun(@(i) numel(descendant_cell{i}), 1:num_class); 
weight_decreasing_factor_between_layer = 0.7; 
weight_of_path_cell = cell(num_semantic_path, 1);
for i = 1:num_semantic_path
    path_i = semantic_path_cell{i};
    layer_i = node_layer_of_each_path{i};
    temp_weight_i = zeros(1, numel(path_i));
    for j = 1:numel(path_i)
        cj = path_i(j); 
        layer_cj = layer_i(j);
        num_child_of_cj = num_child_of_each_class(cj); 
        if layer_cj == 0
            temp_weight_i(j) = 1;
        else
            temp_weight_i(j) = (1/num_child_of_cj) * ...
                (weight_decreasing_factor_between_layer)^(layer_cj); 
        end
    end
    weight_of_path_cell{i} = temp_weight_i; 
end

% compute the weight of each class based on the semantic path cell 
% weight_of_ci = sum of the weight of ci in all semantic paths
weight_of_each_class_based_on_path = zeros(num_class, 1);
for i = 1:num_semantic_path
   path_i = semantic_path_cell{i};
   weight_of_path_i = weight_of_path_cell{i}; 
   for j = 1:numel(path_i)
      cj = path_i(j);
      weight_of_each_class_based_on_path(cj) = ...
          weight_of_each_class_based_on_path(cj) + weight_of_path_i(j); 
   end
end
weight_of_each_class_based_on_path(weight_of_each_class_based_on_path==0) = 1; 

%% summarization and save
semantic_path_structure = struct('data_name', data_name, ...
    'num_paths', num_semantic_path, ...
    'index_of_same_meaning_pair_in_path', index_of_same_meaning_pair_in_path, ...
    'semantic_path_cell', {semantic_path_cell}, ...
    'weight_of_path_cell', {weight_of_path_cell}, ...
    'weight_of_each_class', weight_of_each_class_based_on_path, ...
    'weight_decreasing_factor_between_layer', weight_decreasing_factor_between_layer, ...
    'node_layer_of_each_path', {node_layer_of_each_path'}); 

save_path = fullfile(base_path, 'data', data_name); 
save(fullfile(save_path, [data_name, '_semantic_path_structure']), 'semantic_path_structure'); 

SH_and_SP_structure = struct('data_name', data_name, ...
    'semantic_hierarchy', semantic_hierarchy_structure, ...
    'semantic_path', semantic_path_structure);
save(fullfile(save_path, [data_name, '_SH_and_SP_structure']), 'SH_and_SP_structure'); 


%--------------------------------------------------------------------------
% construct the the semantic path and weight of each training 
% and testing image, according their ground-truth label subset and
% the weighted semantic paths of all candicate classes
%--------------------------------------------------------------------------

% image 9628 and 16308 don't have positive labels, thus remove them
label_train_full = semantic_hierarchy_structure.label_train_SH_augmented;
num_sample_train = size(label_train_full, 2);

%---- construct semantic path of the positive labels of each training image
index_of_null_sample = find(sum(label_train_full==1, 1)==0); % 9628 and 16308
semantic_path_and_weight_cell_train = struct( ...
                  'path', repmat({[]}, 1, num_sample_train), ...
                  'weight', repmat({[]}, 1, num_sample_train));
              
tic
for i = 1: num_sample_train
    subset_i = find(label_train_full(:, i)==1); 
    if ~isempty(subset_i)
        [path_cell_i, weight_cell_i] = find_path_and_weight_of_subset( ...
                 subset_i, SH_and_SP_structure);
        semantic_path_and_weight_cell_train(i).path = path_cell_i; 
        semantic_path_and_weight_cell_train(i).weight = weight_cell_i;
    else
        semantic_path_and_weight_cell_train(i).path = [];
        semantic_path_and_weight_cell_train(i).weight = [];
    end
end
toc


%----- construct semantic path of the positive labels of each testing image
label_test_full = full(semantic_hierarchy_structure.label_test_SH_augmented);
num_sample_test = size(label_test_full, 2);
semantic_path_and_weight_cell_test = struct( ...
                  'path', repmat({[]}, 1, num_sample_test), ...
                  'weight', repmat({[]}, 1, num_sample_test));
tic
for i = 1: num_sample_test
    subset_i = find(label_test_full(:, i)==1); 
    if ~isempty(subset_i)
        [path_cell_i, weight_cell_i] = find_path_and_weight_of_subset( ...
                 subset_i, SH_and_SP_structure);
        semantic_path_and_weight_cell_test(i).path = path_cell_i; 
        semantic_path_and_weight_cell_test(i).weight = weight_cell_i; 
    else
        semantic_path_and_weight_cell_test(i).path = [];
        semantic_path_and_weight_cell_test(i).weight = [];
    end
end
toc

semantic_path_and_weight_cell = struct( ...
                        'train', semantic_path_and_weight_cell_train, ...
                        'test', semantic_path_and_weight_cell_test, ...
                        'index_of_null_sample_in_train', index_of_null_sample);

save_path = fullfile(base_path, 'data', data_name); 
save_name = fullfile(save_path, [data_name, '_semantic_path_and_weight_cell_train_test.mat']);
save(save_name, 'semantic_path_and_weight_cell');

